# 客户端模块设计

## 1. 模块概述

### 1.1 技术栈
- 纯原生 JavaScript (ES6+)
- ES6 Modules
- IndexedDB (本地存储)
- WebSocket API
- Web Audio API (语音录制/播放)
- MediaRecorder API

### 1.2 模块划分

```
client/
├── index.html              # 入口页面
├── assets/
│   ├── css/
│   │   └── style.css      # 样式
│   └── js/
│       ├── main.js        # 入口
│       ├── modules/       # 业务模块
│       │   ├── auth.js           # 认证模块
│       │   ├── connection.js     # 连接模块
│       │   ├── message.js        # 消息模块
│       │   ├── media.js          # 媒体模块
│       │   └── ui.js             # UI模块
│       ├── store/          # 本地存储
│       │   ├── index.js          # IndexedDB封装
│       │   └── schema.js         # 数据库Schema
│       ├── protocol/       # 协议处理
│       │   ├── codec.js          # MessagePack编解码
│       │   └── messages.js       # 消息定义
│       └── utils/          # 工具
│           ├── request.js        # HTTP请求
│           └── helpers.js        # 辅助函数
└── assets.go               # 嵌入静态资源
```

## 2. 模块设计

### 2.1 认证模块 (auth.js)

```javascript
// 认证模块
export class AuthModule {
    constructor(apiClient, store) {
        this.apiClient = apiClient;
        this.store = store;
        this.currentUser = null;
        this.token = null;
    }

    // 注册
    async register(username, password, nickname) {
        const response = await this.apiClient.post('/api/auth/register', {
            username,
            password,
            nickname: nickname || username
        });
        await this._setAuth(response.user, response.token);
        return response.user;
    }

    // 登录
    async login(username, password) {
        const response = await this.apiClient.post('/api/auth/login', {
            username,
            password
        });
        await this._setAuth(response.user, response.token);
        return response.user;
    }

    // 登出
    async logout() {
        await this._clearAuth();
    }

    // 获取当前用户
    getCurrentUser() {
        return this.currentUser;
    }

    // 获取Token
    getToken() {
        return this.token;
    }

    // 检查是否已登录
    isAuthenticated() {
        return this.token !== null;
    }

    // 内部方法
    async _setAuth(user, token) {
        this.currentUser = user;
        this.token = token;
        this.apiClient.setToken(token);
        await this.store.auth.set(user, token);
    }

    async _clearAuth() {
        this.currentUser = null;
        this.token = null;
        this.apiClient.setToken(null);
        await this.store.auth.clear();
    }

    // 从本地恢复会话
    async restoreSession() {
        const authData = await this.store.auth.get();
        if (authData) {
            this.currentUser = authData.user;
            this.token = authData.token;
            this.apiClient.setToken(this.token);
            return true;
        }
        return false;
    }
}
```

### 2.2 连接模块 (connection.js)

```javascript
// 连接模块
export class ConnectionModule {
    constructor(auth, messageModule, config) {
        this.auth = auth;
        this.messageModule = messageModule;
        this.config = config;
        this.ws = null;
        this.connected = false;
        this.authenticated = false;
        this.seq = 0;
        this.pendingAcks = new Map();
        this.reconnectTimer = null;
        this.reconnectAttempts = 0;
    }

    // 连接WebSocket
    connect() {
        const wsUrl = this.config.wsUrl;
        this.ws = new WebSocket(wsUrl);
        this._setupEventHandlers();
    }

    // 设置事件处理
    _setupEventHandlers() {
        this.ws.onopen = () => this._handleOpen();
        this.ws.onclose = () => this._handleClose();
        this.ws.onerror = (error) => this._handleError(error);
        this.ws.onmessage = (event) => this._handleMessage(event);
    }

    // 连接成功
    async _handleOpen() {
        this.connected = true;
        this.reconnectAttempts = 0;

        // 发送认证消息
        await this._authenticate();
    }

    // 认证
    async _authenticate() {
        const payload = {
            token: this.auth.getToken()
        };

        await this.send('MsgAuth', payload);
    }

    // 发送消息
    async send(type, payload) {
        if (!this.connected || !this.authenticated) {
            throw new Error('Not connected');
        }

        const seq = ++this.seq;
        const message = {
            type: this._getMessageType(type),
            seq,
            payload: msgpack.encode(payload)
        };

        this.ws.send(msgpack.encode(message));
        return seq;
    }

    // 处理接收到的消息
    async _handleMessage(event) {
        const data = new Uint8Array(event.data);
        const message = msgpack.decode(data);

        switch (message.type) {
            case 101: // AuthRsp
                await this._handleAuthResponse(message);
                break;
            case 102: // ChatPush
                await this._handleChatPush(message);
                break;
            case 103: // SyncRsp
                await this._handleSyncResponse(message);
                break;
            case 104: // PresencePush
                await this._handlePresencePush(message);
                break;
            case 105: // Pong
                // 心跳响应
                break;
            case 106: // Error
                this._handleError(message);
                break;
        }
    }

    // 处理认证响应
    async _handleAuthResponse(message) {
        const payload = msgpack.decode(message.payload);
        if (payload.success) {
            this.authenticated = true;
            // 请求同步离线消息
            await this.syncOfflineMessages();
        } else {
            console.error('Auth failed:', payload.error);
            this.ws.close();
        }
    }

    // 处理聊天消息推送
    async _handleChatPush(message) {
        const payload = msgpack.decode(message.payload);
        await this.messageModule.receiveMessage(payload);

        // 发送确认
        await this.send('MsgAck', {
            message_id: payload.id,
            status: 'delivered'
        });
    }

    // 同步离线消息
    async syncOfflineMessages() {
        const lastMessage = await this.store.messages.getLast();
        const payload = {
            last_message_id: lastMessage ? lastMessage.id : 0,
            last_sync_time: 0
        };
        await this.send('MsgSyncReq', payload);
    }

    // 断开连接
    disconnect() {
        if (this.ws) {
            this.ws.close();
        }
    }

    // 处理关闭
    _handleClose() {
        this.connected = false;
        this.authenticated = false;

        // 尝试重连
        this._scheduleReconnect();
    }

    // 安排重连
    _scheduleReconnect() {
        const delay = Math.min(
            1000 * Math.pow(1.5, this.reconnectAttempts),
            30000
        );

        this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connect();
        }, delay);
    }

    // 发送心跳
    _startPing() {
        this.pingInterval = setInterval(() => {
            if (this.connected && this.authenticated) {
                this.send('MsgPing', {});
            }
        }, 30000); // 30秒
    }
}
```

### 2.3 消息模块 (message.js)

```javascript
// 消息模块
export class MessageModule {
    constructor(apiClient, connection, store) {
        this.apiClient = apiClient;
        this.connection = connection;
        this.store = store;
        this.conversations = [];
        this.currentConversation = null;
    }

    // 发送文本消息
    async sendText(conversationId, text) {
        const message = {
            conversation_id: conversationId,
            type: 'text',
            content: text,
            created_at: Date.now() / 1000
        };

        // 保存到本地 (状态为sending)
        await this.store.messages.add(message);

        // 通过WebSocket发送
        const conv = this.conversations.find(c => c.id === conversationId);
        const payload = {
            to: conv.participant.id,
            type: 'text',
            content: text
        };

        await this.connection.send('MsgChat', payload);

        return message;
    }

    // 发送媒体消息
    async sendMedia(conversationId, mediaId, type) {
        const message = {
            conversation_id: conversationId,
            type,
            content: mediaId,
            created_at: Date.now() / 1000
        };

        await this.store.messages.add(message);

        const conv = this.conversations.find(c => c.id === conversationId);
        const payload = {
            to: conv.participant.id,
            type,
            content: mediaId
        };

        await this.connection.send('MsgChat', payload);

        return message;
    }

    // 接收消息
    async receiveMessage(payload) {
        const message = {
            id: payload.id,
            conversation_id: payload.conversation_id,
            sender_id: payload.sender_id,
            receiver_id: payload.receiver_id,
            type: payload.type,
            content: payload.content,
            status: payload.status,
            created_at: payload.created_at
        };

        // 保存到本地
        await this.store.messages.add(message);

        // 通知UI更新
        this._notifyMessageReceived(message);
    }

    // 获取会话列表
    async loadConversations() {
        const response = await this.apiClient.get('/api/conversations');
        this.conversations = response.conversations;
        return this.conversations;
    }

    // 获取会话消息
    async loadMessages(conversationId, beforeId = null, limit = 50) {
        let url = `/api/conversations/${conversationId}/messages?limit=${limit}`;
        if (beforeId) {
            url += `&before_id=${beforeId}`;
        }

        const response = await this.apiClient.get(url);

        // 保存到本地
        for (const msg of response.messages) {
            await this.store.messages.addOrUpdate(msg);
        }

        return response.messages;
    }

    // 标记已读
    async markAsRead(conversationId) {
        await this.apiClient.post(`/api/conversations/${conversationId}/read`);

        // 更新本地消息状态
        await this.store.messages.markAsRead(conversationId);
    }

    // 获取或创建与用户的会话
    async getConversationWithUser(userId) {
        const response = await this.apiClient.get(`/api/conversations/with/${userId}`);

        // 添加到会话列表
        const existing = this.conversations.find(c => c.id === response.id);
        if (!existing) {
            this.conversations.unshift(response);
        }

        return response;
    }

    // 事件通知
    _notifyMessageReceived(message) {
        // 触发自定义事件
        window.dispatchEvent(new CustomEvent('message:received', {
            detail: message
        }));
    }
}
```

### 2.4 媒体模块 (media.js)

```javascript
// 媒体模块
export class MediaModule {
    constructor(apiClient, store) {
        this.apiClient = apiClient;
        this.store = store;
    }

    // 上传文件
    async uploadFile(file, type) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('type', type);

        const response = await this.apiClient.post('/api/media/upload', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        });

        // 缓存媒体信息
        await this.store.media.add(response);

        return response;
    }

    // 上传图片
    async uploadImage(file) {
        if (!file.type.startsWith('image/')) {
            throw new Error('Not an image file');
        }

        // 验证大小 (5MB)
        if (file.size > 5 * 1024 * 1024) {
            throw new Error('Image too large (max 5MB)');
        }

        return this.uploadFile(file, 'image');
    }

    // 上传语音
    async uploadVoice(file) {
        if (!file.type.startsWith('audio/')) {
            throw new Error('Not an audio file');
        }

        // 验证大小 (10MB)
        if (file.size > 10 * 1024 * 1024) {
            throw new Error('Audio too large (max 10MB)');
        }

        return this.uploadFile(file, 'voice');
    }

    // 获取媒体URL
    getMediaUrl(mediaId, thumbnail = false) {
        return thumbnail
            ? `/api/media/${mediaId}/thumb`
            : `/api/media/${mediaId}`;
    }

    // 从本地缓存获取媒体信息
    async getCachedMedia(mediaId) {
        return this.store.media.get(mediaId);
    }
}
```

### 2.5 UI模块 (ui.js)

```javascript
// UI模块
export class UIModule {
    constructor(auth, connection, message, media) {
        this.auth = auth;
        this.connection = connection;
        this.message = message;
        this.media = media;
        this.currentView = null;
    }

    // 初始化
    init() {
        this._setupEventListeners();
        this._checkAuth();
    }

    // 设置事件监听
    _setupEventListeners() {
        // 消息接收事件
        window.addEventListener('message:received', (e) => {
            this._handleMessageReceived(e.detail);
        });

        // 连接状态变化
        window.addEventListener('connection:change', (e) => {
            this._updateConnectionStatus(e.detail.connected);
        });
    }

    // 检查认证状态
    async _checkAuth() {
        const hasSession = await this.auth.restoreSession();

        if (!hasSession) {
            this._showLoginView();
        } else {
            this._showMainView();
        }
    }

    // 显示登录视图
    _showLoginView() {
        this.currentView = 'login';
        this._renderLogin();
    }

    // 显示主视图
    _showMainView() {
        this.currentView = 'main';
        this._connect();
        this._renderMain();
    }

    // 连接WebSocket
    async _connect() {
        this.connection.connect();
    }

    // 渲染登录界面
    _renderLogin() {
        const app = document.getElementById('app');
        app.innerHTML = `
            <div class="login-container">
                <h1>zMessage</h1>
                <form id="login-form">
                    <input type="text" id="username" placeholder="用户名" required>
                    <input type="password" id="password" placeholder="密码" required>
                    <button type="submit">登录</button>
                </form>
                <p>还没有账号? <a href="#" id="register-link">注册</a></p>
            </div>
        `;

        document.getElementById('login-form').addEventListener('submit', (e) => {
            e.preventDefault();
            this._handleLogin();
        });
    }

    // 处理登录
    async _handleLogin() {
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;

        try {
            await this.auth.login(username, password);
            this._showMainView();
        } catch (error) {
            alert('登录失败: ' + error.message);
        }
    }

    // 渲染主界面
    async _renderMain() {
        const app = document.getElementById('app');
        app.innerHTML = `
            <div class="main-container">
                <aside class="sidebar">
                    <div class="user-info">
                        <span>${this.auth.getCurrentUser().nickname}</span>
                        <button id="logout-btn">退出</button>
                    </div>
                    <div class="conversation-list" id="conversation-list">
                        <p>加载中...</p>
                    </div>
                </aside>
                <main class="chat-area">
                    <div id="chat-container">
                        <p>选择一个会话开始聊天</p>
                    </div>
                </main>
            </div>
        `;

        // 加载会话列表
        await this._loadConversationList();
    }

    // 加载会话列表
    async _loadConversationList() {
        const conversations = await this.message.loadConversations();
        this._renderConversationList(conversations);
    }

    // 渲染会话列表
    _renderConversationList(conversations) {
        const list = document.getElementById('conversation-list');
        list.innerHTML = conversations.map(conv => `
            <div class="conversation-item" data-id="${conv.id}">
                <div class="avatar">${conv.participant.nickname[0]}</div>
                <div class="info">
                    <div class="name">${conv.participant.nickname}</div>
                    <div class="last-message">${this._formatLastMessage(conv.last_message)}</div>
                </div>
                ${conv.unread_count > 0 ? `<div class="badge">${conv.unread_count}</div>` : ''}
            </div>
        `).join('');

        // 绑定点击事件
        list.querySelectorAll('.conversation-item').forEach(item => {
            item.addEventListener('click', () => {
                this._openConversation(parseInt(item.dataset.id));
            });
        });
    }

    // 打开会话
    async _openConversation(conversationId) {
        this.message.currentConversation = conversationId;
        await this.message.markAsRead(conversationId);
        await this._loadMessages(conversationId);
    }

    // 加载消息
    async _loadMessages(conversationId) {
        const messages = await this.message.loadMessages(conversationId);
        this._renderMessages(messages);
    }

    // 渲染消息
    _renderMessages(messages) {
        const container = document.getElementById('chat-container');
        const currentUser = this.auth.getCurrentUser();

        container.innerHTML = messages.map(msg => {
            const isOwn = msg.sender_id === currentUser.id;
            return `
                <div class="message ${isOwn ? 'own' : 'other'}">
                    ${this._renderMessageContent(msg)}
                </div>
            `;
        }).join('');

        container.scrollTop = container.scrollHeight;
    }

    // 渲染消息内容
    _renderMessageContent(msg) {
        switch (msg.type) {
            case 'text':
                return `<div class="message-content">${this._escapeHtml(msg.content)}</div>`;
            case 'image':
                return `<img src="${this.media.getMediaUrl(msg.content)}" alt="图片" class="message-image">`;
            case 'voice':
                return `<audio src="${this.media.getMediaUrl(msg.content)}" controls class="message-voice"></audio>`;
            default:
                return `<div class="message-content">[不支持的消息类型]</div>`;
        }
    }

    // 处理消息接收
    _handleMessageReceived(message) {
        // 如果是当前会话的消息, 刷新界面
        if (message.conversation_id === this.message.currentConversation) {
            this._appendMessage(message);
        }

        // 更新会话列表
        this._loadConversationList();
    }

    // 追加消息到界面
    _appendMessage(message) {
        const container = document.getElementById('chat-container');
        const currentUser = this.auth.getCurrentUser();
        const isOwn = message.sender_id === currentUser.id;

        const msgEl = document.createElement('div');
        msgEl.className = `message ${isOwn ? 'own' : 'other'}`;
        msgEl.innerHTML = this._renderMessageContent(message);

        container.appendChild(msgEl);
        container.scrollTop = container.scrollHeight;
    }

    // 工具方法
    _escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    _formatLastMessage(msg) {
        if (!msg) return '暂无消息';
        const type = msg.type === 'text' ? msg.content : '[媒体]';
        return type.substring(0, 30);
    }
}
```

### 2.6 本地存储 (store/index.js)

```javascript
// IndexedDB 封装
export class Store {
    constructor() {
        this.dbName = 'zMessage';
        this.dbVersion = 1;
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // 用户数据存储
                if (!db.objectStoreNames.contains('auth')) {
                    db.createObjectStore('auth', { keyPath: 'id' });
                }

                // 消息存储
                if (!db.objectStoreNames.contains('messages')) {
                    const msgStore = db.createObjectStore('messages', { keyPath: 'id' });
                    msgStore.createIndex('conversation_id', 'conversation_id', { unique: false });
                }

                // 会话存储
                if (!db.objectStoreNames.contains('conversations')) {
                    db.createObjectStore('conversations', { keyPath: 'id' });
                }

                // 媒体缓存
                if (!db.objectStoreNames.contains('media')) {
                    db.createObjectStore('media', { keyPath: 'id' });
                }
            };
        });
    }

    // 认证数据
    get auth() {
        return new AuthStore(this.db);
    }

    // 消息数据
    get messages() {
        return new MessageStore(this.db);
    }

    // 会话数据
    get conversations() {
        return new ConversationStore(this.db);
    }

    // 媒体数据
    get media() {
        return new MediaStore(this.db);
    }
}

class AuthStore {
    constructor(db) {
        this.db = db;
    }

    async set(user, token) {
        const tx = this.db.transaction('auth', 'readwrite');
        const store = tx.objectStore('auth');
        store.put({ id: 'current', user, token });
    }

    async get() {
        const tx = this.db.transaction('auth', 'readonly');
        const store = tx.objectStore('auth');
        const result = await store.get('current');
        return result;
    }

    async clear() {
        const tx = this.db.transaction('auth', 'readwrite');
        const store = tx.objectStore('auth');
        store.delete('current');
    }
}

class MessageStore {
    constructor(db) {
        this.db = db;
    }

    async add(message) {
        const tx = this.db.transaction('messages', 'readwrite');
        const store = tx.objectStore('messages');
        store.put(message);
    }

    async addOrUpdate(message) {
        const tx = this.db.transaction('messages', 'readwrite');
        const store = tx.objectStore('messages');
        store.put(message);
    }

    async getByConversation(conversationId) {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction('messages', 'readonly');
            const store = tx.objectStore('messages');
            const index = store.index('conversation_id');
            const request = index.getAll(conversationId);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async getLast() {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction('messages', 'readonly');
            const store = tx.objectStore('messages');
            const request = store.openCursor(null, 'prev');

            request.onsuccess = () => {
                const cursor = request.result;
                resolve(cursor ? cursor.value : null);
            };
            request.onerror = () => reject(request.error);
        });
    }

    async markAsRead(conversationId) {
        // 更新会话的所有消息状态为read
    }
}
```

## 3. 协议处理

### 3.1 MessagePack 编解码

```javascript
// protocol/codec.js
import msgpack from 'https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/dist/msgpack.min.js';

export const codec = {
    encode(data) {
        return msgpack.encode(data);
    },

    decode(buffer) {
        return msgpack.decode(new Uint8Array(buffer));
    }
};
```

### 3.2 消息定义

```javascript
// protocol/messages.js
export const MessageType = {
    // 客户端 → 服务端
    MsgAuth: 1,
    MsgChat: 2,
    MsgAck: 3,
    MsgSyncReq: 4,
    MsgPresence: 5,
    MsgPing: 6,

    // 服务端 → 客户端
    MsgAuthRsp: 101,
    MsgChatPush: 102,
    MsgSyncRsp: 103,
    MsgPresencePush: 104,
    MsgPong: 105,
    MsgError: 106
};
```

## 4. HTTP 请求封装

```javascript
// utils/request.js
export class ApiClient {
    constructor(baseURL) {
        this.baseURL = baseURL;
        this.token = null;
    }

    setToken(token) {
        this.token = token;
    }

    async request(method, path, data = null, options = {}) {
        const url = this.baseURL + path;
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };

        if (this.token) {
            headers['Authorization'] = `Bearer ${this.token}`;
        }

        const config = {
            method,
            headers,
            ...options
        };

        if (data) {
            if (headers['Content-Type'] === 'multipart/form-data') {
                // FormData 不需要设置 Content-Type
                delete headers['Content-Type'];
                config.body = data;
            } else {
                config.body = JSON.stringify(data);
            }
        }

        const response = await fetch(url, config);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return response.json();
    }

    get(path, options) {
        return this.request('GET', path, null, options);
    }

    post(path, data, options) {
        return this.request('POST', path, data, options);
    }

    put(path, data, options) {
        return this.request('PUT', path, data, options);
    }

    delete(path, options) {
        return this.request('DELETE', path, null, options);
    }
}
```

## 5. 浏览器兼容性

| 特性 | Chrome | Firefox | Safari |
|------|--------|---------|--------|
| ES6 Modules | 61+ | 60+ | 11+ |
| IndexedDB | 24+ | 16+ | 7+ |
| WebSocket | 16+ | 11+ | 7+ |
| MediaRecorder | 49+ | 25+ | 14.1+ |

## 6. 测试要点

- [ ] 登录注册流程
- [ ] WebSocket连接和认证
- [ ] 发送接收文本消息
- [ ] 上传和显示图片
- [ ] 录制和发送语音
- [ ] 会话列表加载
- [ ] 消息历史加载
- [ ] 离线消息同步
- [ ] 重连机制
- [ ] 本地数据存储
